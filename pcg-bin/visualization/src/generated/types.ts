// This file has been generated by Specta. DO NOT EDIT.

/**
 * A pair of a PCG action and a debug context (indicating the source of the
 * action).
 */
export type ActionKindWithDebugCtxt<T> = { kind: T; debug_context: string | null }

export type BorrowPcgActionKindDebugRepr = { type: BorrowPcgActionKindDiscriminants; data: string }

/**
 * Auto-generated discriminant enum variants
 */
export type BorrowPcgActionKindDiscriminants = "LabelLifetimeProjection" | "Weaken" | "Restore" | "MakePlaceOld" | 
/**
 * Remove an edge from the PCG. In terms of the PCG itself, the validity
 * conditions associated with the edge are not relevant (there is no
 * situation where an edge is removed only under certain conditions).
 * However, clients may be interested in the conditions, for example, the
 * symbolic-execution based Prusti purification already performs some
 * filtering on edges based on validity conditions and might want to ignore
 * removal actions for edges that it already ignored.
 */
"RemoveEdge" | "AddEdge"

export type CapabilityKind = 
/**
 * For borrowed places only: permits reads from the location, but not writes or
 * drops.
 */
"Read" | 
/**
 * For owned places, this capability is used when the place is moved out
 * of. This capability is used for both owned and borrowed places just before
 * they are overwritten.
 */
"Write" | 
/**
 * Writes and reads are permitted to this place, and the place is not
 * borrowed.
 */
"Exclusive" | 
/**
 * [`CapabilityKind::Exclusive`] for everything not through a dereference,
 * [`CapabilityKind::Write`] for everything through a dereference.
 */
"ShallowExclusive"

export type Conditioned<T, Conditions> = { conditions: Conditions; value: T }

export type EvalStmtData<T> = { pre_operands: T; post_operands: T; pre_main: T; post_main: T }

export type EvalStmtPhase = "pre_operands" | "post_operands" | "pre_main" | "post_main"

export type FunctionMetadata = { name: string; source: string; start: SourcePos }

export type MirEdge = { source: string; target: string; label: string }

export type MirGraph = { nodes: MirNode[]; edges: MirEdge[] }

export type MirNode = { id: string; block: number; stmts: MirStmt[]; terminator: MirStmt }

export type MirStmt = { stmt: string; span: MirStmtSpan; loans_invalidated_start: string[]; loans_invalidated_mid: string[]; borrows_in_scope_start: string[]; borrows_in_scope_mid: string[] }

export type MirStmtSpan = { low: SourcePos; high: SourcePos }

export type PcgActionDebugRepr = { type: "Owned"; data: ActionKindWithDebugCtxt<RepackOp<string, string, string>> } | { type: "Borrow"; data: ActionKindWithDebugCtxt<BorrowPcgActionKindDebugRepr> }

export type PcgStmtVisualizationData = { actions: EvalStmtData<PcgActionDebugRepr[]> }

export type PcgSuccessorVisualizationData = { actions: PcgActionDebugRepr[] }

export type RepackCollapse<Place, Guide> = { to: Place; capability: CapabilityKind; guide: Guide | null }

export type RepackExpand<Place, Guide> = { from: Place; guide: Guide | null; capability: CapabilityKind }

export type RepackOp<Local, Place, Guide> = 
/**
 * Rust will sometimes join two BasicBlocks where a local is live in one and dead in the other.
 * Our analysis will join these two into a state where the local is dead, and this Op marks the
 * edge from where it was live.
 * 
 * This is not an issue in the MIR since it generally has a
 * [`mir::StatementKind::StorageDead`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.StatementKind.html#variant.StorageDead)
 * right after the merge point, which is fine in Rust semantics, since
 * [`mir::StatementKind::StorageDead`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.StatementKind.html#variant.StorageDead)
 * is a no-op if the local is already (conditionally) dead.
 * 
 * This Op only appears for edges between basic blocks. It is often emitted for edges to panic
 * handling blocks, but can also appear in regular code for example in the MIR of
 * [this function](https://github.com/dtolnay/syn/blob/3da56a712abf7933b91954dbfb5708b452f88504/src/attr.rs#L623-L628).
 */
{ type: "StorageDead"; data: Local } | 
/**
 * This Op only appears within a BasicBlock and is attached to a
 * [`mir::StatementKind::StorageDead`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.StatementKind.html#variant.StorageDead)
 * statement. We emit it for any such statement where the local may already be dead. We
 * guarantee to have inserted a [`RepackOp::StorageDead`] before this Op so that one can
 * safely ignore the statement this is attached to.
 */
{ type: "IgnoreStorageDead"; data: Local } | 
/**
 * Instructs that the current capability to the place (first [`CapabilityKind`]) should
 * be weakened to the second given capability. We guarantee that `_.1 > _.2`.
 * 
 * This Op is used prior to a [`RepackOp::Collapse`] to ensure that all packed up places have
 * the same capability. It can also appear at basic block join points, where one branch has
 * a weaker capability than the other.
 */
{ type: "Weaken"; data: Weaken<Place, CapabilityKind> } | 
/**
 * Instructs that one should unpack `place` with the capability.
 * We guarantee that the current state holds exactly the given capability for the given place.
 * `guide` denotes e.g. the enum variant to unpack to. One can use
 * [`Place::expand_one_level(_.0, _.1, ..)`](Place::expand_one_level) to get the set of all
 * places (except as noted in the documentation for that fn) which will be obtained by unpacking.
 */
{ type: "Expand"; data: RepackExpand<Place, Guide> } | 
/**
 * Instructs that one should pack up `place` with the given capability.
 * `guide` denotes e.g. the enum variant to pack from. One can use
 * [`Place::expand_one_level(_.0, _.1, ..)`](Place::expand_one_level) to get the set of all
 * places which should be packed up. We guarantee that the current state holds exactly the
 * given capability for all places in this set.
 */
{ type: "Collapse"; data: RepackCollapse<Place, Guide> } | 
/**
 * TODO
 */
{ type: "DerefShallowInit"; data: [Place, Place] } | 
/**
 * This place should have its capability changed from `Lent` (for mutably
 * borrowed places) or `Read` (for shared borrow places), to the given
 * capability, because it is no longer lent out.
 */
{ type: "RegainLoanedCapability"; data: [Place, CapabilityKind] }

export type SourcePos = { line: number; column: number }

export type StmtGraphs<PhaseKey> = { at_phase: ([PhaseKey, string])[]; actions: EvalStmtData<string[]> }

/**
 * Instructs that the current capability to the place (first [`CapabilityKind`]) should
 * be weakened to the second given capability. We guarantee that `_.1 > _.2`.
 * If `_.2` is `None`, the capability is removed.
 */
export type Weaken<Place, ToCap> = { place: Place; from: CapabilityKind; to: ToCap }

