//! Actions describing manipulations of the PCG.
use std::{borrow::Cow, marker::PhantomData};

use derive_more::{Deref, DerefMut, From};
use serde_derive::Serialize;

use crate::{
    DebugDataTypes,
    borrow_pcg::{
        action::{
            ApplyActionResult, BorrowPcgActionKind, BorrowPcgActionKindDebugRepr,
            actions::BorrowPcgActions,
        },
        edge::kind::BorrowPcgEdgeKind,
        unblock_graph::BorrowPcgUnblockAction,
        validity_conditions::ValidityConditions,
    },
    owned_pcg::{PcgRepackOpDataTypes, RegainedCapability, RepackOp},
    pcg::capabilities::PositiveCapability,
    rustc_interface::middle::mir,
    utils::{
        DebugRepr, HasBorrowCheckerCtxt, PcgNodeComponent, Place, PlaceLike,
        display::{DisplayOutput, DisplayWithCtxt, OutputMode},
    },
};

#[derive(Clone, Debug, PartialEq, Eq, Serialize)]
#[cfg_attr(feature = "type-export", derive(ts_rs::TS))]
#[cfg_attr(feature = "type-export", ts(export, concrete(Action=PcgActionDebugRepr, Result=ApplyActionResult<String>)))]
pub(crate) struct AppliedAction<'tcx, Action = PcgAction<'tcx>, Result = ApplyActionResult> {
    pub(crate) action: Action,
    pub(crate) result: Result,
    _marker: PhantomData<&'tcx ()>,
}

impl<'tcx> AppliedAction<'tcx> {
    pub(crate) fn new(action: PcgAction<'tcx>, result: ApplyActionResult) -> Self {
        AppliedAction {
            action,
            result,
            _marker: PhantomData,
        }
    }
}

pub(crate) type AppliedActionDebugRepr =
    AppliedAction<'static, PcgActionDebugRepr, ApplyActionResult<String>>;

impl<'a, 'tcx: 'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>> DebugRepr<Ctxt> for AppliedAction<'tcx> {
    type Repr = AppliedActionDebugRepr;

    fn debug_repr(&self, ctxt: Ctxt) -> Self::Repr {
        AppliedAction {
            action: self.action.debug_repr(ctxt),
            result: self.result.debug_repr(()),
            _marker: PhantomData,
        }
    }
}

pub(crate) type AppliedActions<'tcx> = PcgActions<'tcx, AppliedAction<'tcx>>;

impl Default for AppliedActions<'_> {
    fn default() -> Self {
        Self {
            actions: vec![],
            _marker: PhantomData,
        }
    }
}

pub type PcgActionsRef<'slf, 'tcx> = PcgActions<'tcx, &'slf PcgAction<'tcx>>;

/// An ordered list of PCG actions, generated by the PCG analysis (typically as
/// the result of analyzing a statement)
#[derive(Clone, Debug, From, Default, Deref, DerefMut, PartialEq, Eq)]
pub struct PcgActions<'tcx, Action = PcgAction<'tcx>> {
    #[deref]
    #[deref_mut]
    pub(crate) actions: Vec<Action>,
    _marker: PhantomData<&'tcx ()>,
}

impl<'tcx, Action> PcgActions<'tcx, Action> {
    pub(crate) fn new(actions: Vec<Action>) -> Self {
        Self {
            actions,
            _marker: PhantomData,
        }
    }

    pub(crate) fn map_actions<T>(&self, f: impl Fn(&Action) -> T) -> PcgActions<'tcx, T> {
        PcgActions::new(self.actions.iter().map(f).collect())
    }
}

impl<'a, 'tcx: 'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>, Action: DebugRepr<Ctxt>> DebugRepr<Ctxt>
    for PcgActions<'tcx, Action>
{
    type Repr = Vec<Action::Repr>;

    fn debug_repr(&self, ctxt: Ctxt) -> Self::Repr {
        self.actions.iter().map(|a| a.debug_repr(ctxt)).collect()
    }
}

impl<'tcx> From<BorrowPcgActions<'tcx>> for PcgActions<'tcx> {
    fn from(actions: BorrowPcgActions<'tcx>) -> Self {
        PcgActions::new(
            actions
                .0
                .into_iter()
                .map(std::convert::Into::into)
                .collect::<Vec<_>>(),
        )
    }
}

impl<'tcx> From<Vec<OwnedPcgAction<'tcx>>> for PcgActions<'tcx> {
    fn from(actions: Vec<OwnedPcgAction<'tcx>>) -> Self {
        PcgActions::new(
            actions
                .into_iter()
                .map(std::convert::Into::into)
                .collect::<Vec<_>>(),
        )
    }
}

impl<'tcx> PcgActions<'tcx> {
    pub(crate) fn extend(&mut self, actions: PcgActions<'tcx>) {
        self.actions.extend(actions.actions);
    }

    /// The subset of actions applied to the Borrow PCG.
    #[must_use]
    pub fn borrow_pcg_actions(&self) -> BorrowPcgActions<'tcx> {
        BorrowPcgActions(
            self.actions
                .iter()
                .filter_map(|action| match action {
                    PcgAction::Borrow(action) => Some(action.clone()),
                    _ => None,
                })
                .collect(),
        )
    }

    pub fn iter(&self) -> impl Iterator<Item = &PcgAction<'tcx>> {
        self.actions.iter()
    }

    /// The subset of actions applied to the Owned PCG.
    #[must_use]
    pub fn owned_pcg_actions(&self) -> Vec<&OwnedPcgAction<'tcx>> {
        self.actions
            .iter()
            .filter_map(|action| match action {
                PcgAction::Owned(action) => Some(action),
                _ => None,
            })
            .collect()
    }

    /// The subset of actions that unblock nodes in the Borrow PCG.
    #[must_use]
    pub fn borrow_pcg_unblock_actions(&self) -> Vec<BorrowPcgUnblockAction<'tcx>> {
        self.actions
            .iter()
            .filter_map(|action| match action {
                PcgAction::Borrow(BorrowPcgAction {
                    kind: BorrowPcgActionKind::RemoveEdge(edge),
                    ..
                }) => Some(BorrowPcgUnblockAction::new(edge.clone())),
                _ => None,
            })
            .collect()
    }
}

/// A pair of a PCG action and a debug context (indicating the source of the
/// action and possibly its effects).
#[derive(Clone, Debug, PartialEq, Eq, Serialize)]
#[cfg_attr(feature = "type-export", derive(ts_rs::TS))]
pub struct ActionKindWithDebugInfo<T, DebugInfo = Option<DisplayOutput>> {
    pub(crate) kind: T,
    pub(crate) debug_info: DebugInfo,
}

impl<T> ActionKindWithDebugInfo<T> {
    pub fn kind(&self) -> &T {
        &self.kind
    }

    pub(crate) fn new(kind: T, debug_info: Option<DisplayOutput>) -> Self {
        Self { kind, debug_info }
    }

    pub(crate) fn debug_line<Ctxt>(&self, ctxt: Ctxt) -> Cow<'static, str>
    where
        T: DisplayWithCtxt<Ctxt>,
    {
        self.kind.display_output(ctxt, OutputMode::Test).into_text()
    }
}

impl<Ctxt, T: DebugRepr<Ctxt>> DebugRepr<Ctxt> for ActionKindWithDebugInfo<T> {
    type Repr = ActionKindWithDebugInfo<T::Repr, Option<String>>;
    fn debug_repr(&self, ctxt: Ctxt) -> Self::Repr {
        ActionKindWithDebugInfo {
            kind: self.kind.debug_repr(ctxt),
            debug_info: self.debug_info.as_ref().map(|ctxt| ctxt.debug_repr(())),
        }
    }
}

impl<Ctxt, T: DisplayWithCtxt<Ctxt>> DisplayWithCtxt<Ctxt> for ActionKindWithDebugInfo<T> {
    fn display_output(&self, ctxt: Ctxt, mode: OutputMode) -> DisplayOutput {
        self.kind.display_output(ctxt, mode)
    }
}

/// An action applied to the Owned PCG during the PCG analysis
/// for which consumers (e.g. Prusti) may wish to perform
/// their own effect (e.g. folding a predicate).
pub type OwnedPcgAction<'tcx, P = Place<'tcx>> =
    ActionKindWithDebugInfo<RepackOp<'tcx, PcgRepackOpDataTypes<'tcx, P>>>;

/// An action applied to the Borrow PCG during the PCG analysis
/// for which consumers (e.g. Prusti) may wish to perform
/// their own effect (e.g. for an unblock, applying a magic wand).
pub type BorrowPcgAction<
    'tcx,
    EdgeKind = BorrowPcgEdgeKind<'tcx>,
    P = Place<'tcx>,
    VC = ValidityConditions,
> = ActionKindWithDebugInfo<BorrowPcgActionKind<'tcx, EdgeKind, P, VC>>;

mod private {
    use serde_derive::Serialize;

    #[cfg_attr(feature = "type-export", derive(ts_rs::TS))]
    #[cfg_attr(
        feature = "type-export",
        ts(bound = "Borrow: ts_rs::TS, Owned: ts_rs::TS")
    )]
    #[derive(Clone, PartialEq, Eq, Debug, Serialize)]
    #[serde(tag = "type", content = "data")]
    pub enum GenericPcgAction<Borrow, Owned> {
        Borrow(Borrow),
        Owned(Owned),
    }
}

impl<'tcx, EdgeKind, P: std::fmt::Debug, VC> From<BorrowPcgAction<'tcx, EdgeKind, P, VC>>
    for PcgAction<'tcx, EdgeKind, P, VC>
{
    fn from(action: BorrowPcgAction<'tcx, EdgeKind, P, VC>) -> PcgAction<'tcx, EdgeKind, P, VC> {
        PcgAction::<'tcx, EdgeKind, P, VC>::Borrow(action)
    }
}

impl<'tcx, EdgeKind, P: std::fmt::Debug, VC> From<OwnedPcgAction<'tcx, P>>
    for PcgAction<'tcx, EdgeKind, P, VC>
{
    fn from(action: OwnedPcgAction<'tcx, P>) -> Self {
        PcgAction::<'tcx, EdgeKind, P, VC>::Owned(action)
    }
}

/// An action applied to the PCG during the PCG analysis.
pub type PcgAction<
    'tcx,
    EdgeKind = BorrowPcgEdgeKind<'tcx>,
    P = Place<'tcx>,
    VC = ValidityConditions,
> = private::GenericPcgAction<BorrowPcgAction<'tcx, EdgeKind, P, VC>, OwnedPcgAction<'tcx, P>>;

pub(crate) type PcgActionDebugRepr = private::GenericPcgAction<
    ActionKindWithDebugInfo<BorrowPcgActionKindDebugRepr, Option<String>>,
    ActionKindWithDebugInfo<RepackOp<'static, DebugDataTypes>, Option<String>>,
>;

impl<'a, 'tcx: 'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>> DebugRepr<Ctxt> for PcgAction<'tcx> {
    type Repr = PcgActionDebugRepr;

    fn debug_repr(&self, ctxt: Ctxt) -> Self::Repr {
        match self {
            PcgAction::Borrow(action) => PcgActionDebugRepr::Borrow(action.debug_repr(ctxt)),
            PcgAction::Owned(action) => PcgActionDebugRepr::Owned(action.debug_repr(ctxt)),
        }
    }
}

impl<'tcx, P: PcgNodeComponent, VC> PcgAction<'tcx, BorrowPcgEdgeKind<'tcx, P>, P, VC> {
    pub(crate) fn restore_capability<Ctxt>(
        place: P,
        capability: PositiveCapability,
        debug_context: impl Into<DisplayOutput>,
        ctxt: Ctxt,
    ) -> Self
    where
        P: PlaceLike<'tcx, Ctxt>,
    {
        let debug_context: DisplayOutput = debug_context.into();
        if place.is_owned(ctxt) {
            PcgAction::<'tcx, BorrowPcgEdgeKind<'tcx, P>, P, VC>::Owned(OwnedPcgAction {
                kind: RepackOp::RegainLoanedCapability(RegainedCapability::new(place, capability)),
                debug_info: Some(debug_context),
            })
        } else {
            BorrowPcgAction::restore_capability(place, capability, debug_context).into()
        }
    }
}

impl<'tcx, EdgeKind, P: PcgNodeComponent, VC> PcgAction<'tcx, EdgeKind, P, VC> {
    pub(crate) fn debug_line<Ctxt: Copy>(&self, ctxt: Ctxt) -> Cow<'static, str>
    where
        BorrowPcgActionKind<'tcx, EdgeKind, P, VC>: DisplayWithCtxt<Ctxt>,
        OwnedPcgAction<'tcx, P>: DisplayWithCtxt<Ctxt>,
        P: DisplayWithCtxt<Ctxt>,
    {
        match self {
            PcgAction::Borrow(action) => action.debug_line(ctxt),
            PcgAction::Owned(action) => action.debug_line(ctxt),
        }
    }
}
