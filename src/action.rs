//! Actions describing manipulations of the PCG.
use derive_more::{Deref, DerefMut, From};
use serde_json::Map;

use crate::{
    borrow_checker::BorrowCheckerInterface,
    borrow_pcg::{
        action::{BorrowPcgActionKind, actions::BorrowPcgActions},
        edge::kind::BorrowPcgEdgeKind,
        unblock_graph::BorrowPcgUnblockAction,
    },
    owned_pcg::RepackOp,
    pcg::capabilities::CapabilityKind,
    utils::{
        CompilerCtxt, HasBorrowCheckerCtxt, HasCompilerCtxt, Place,
        display::{DisplayWithCompilerCtxt, DisplayWithCtxt},
        json::{ToJsonWithCompilerCtxt, ToJsonWithCtxt},
    },
};

/// An ordered list of PCG actions, generated by the PCG analysis (typically as
/// the result of analyzing a statement)
#[derive(Clone, PartialEq, Eq, Debug, From, Default, Deref, DerefMut)]
pub struct PcgActions<'tcx>(pub(crate) Vec<PcgAction<'tcx>>);

impl<'a, 'tcx: 'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>> ToJsonWithCtxt<Ctxt> for PcgActions<'tcx> {
    fn to_json(&self, ctxt: Ctxt) -> serde_json::Value {
        self.0.iter().map(|a| a.to_json(ctxt)).collect()
    }
}

impl<'tcx> From<BorrowPcgActions<'tcx>> for PcgActions<'tcx> {
    fn from(actions: BorrowPcgActions<'tcx>) -> Self {
        PcgActions(actions.0.into_iter().map(|a| a.into()).collect::<Vec<_>>())
    }
}

impl<'tcx> From<Vec<OwnedPcgAction<'tcx>>> for PcgActions<'tcx> {
    fn from(actions: Vec<OwnedPcgAction<'tcx>>) -> Self {
        PcgActions(actions.into_iter().map(|a| a.into()).collect::<Vec<_>>())
    }
}

impl<'tcx> PcgActions<'tcx> {
    pub(crate) fn extend(&mut self, actions: PcgActions<'tcx>) {
        self.0.extend(actions.0);
    }

    /// The subset of actions applied to the Borrow PCG.
    pub fn borrow_pcg_actions(&self) -> BorrowPcgActions<'tcx> {
        BorrowPcgActions(
            self.0
                .iter()
                .filter_map(|action| match action {
                    PcgAction::Borrow(action) => Some(action.clone()),
                    _ => None,
                })
                .collect(),
        )
    }

    pub fn iter(&self) -> impl Iterator<Item = &PcgAction<'tcx>> {
        self.0.iter()
    }

    /// The subset of actions applied to the Owned PCG.
    pub fn owned_pcg_actions(&self) -> Vec<&OwnedPcgAction<'tcx>> {
        self.0
            .iter()
            .filter_map(|action| match action {
                PcgAction::Owned(action) => Some(action),
                _ => None,
            })
            .collect()
    }

    /// The subset of actions that unblock nodes in the Borrow PCG.
    pub fn borrow_pcg_unblock_actions(&self) -> Vec<BorrowPcgUnblockAction<'tcx>> {
        self.0
            .iter()
            .filter_map(|action| match action {
                PcgAction::Borrow(BorrowPcgAction {
                    kind: BorrowPcgActionKind::RemoveEdge(edge),
                    ..
                }) => Some(BorrowPcgUnblockAction::new(edge.clone())),
                _ => None,
            })
            .collect()
    }
}

/// A pair of a PCG action and a debug context (indicating the source of the
/// action).
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ActionKindWithDebugCtxt<T> {
    pub(crate) kind: T,
    pub(crate) debug_context: Option<String>,
}

impl<T> ActionKindWithDebugCtxt<T> {
    pub fn kind(&self) -> &T {
        &self.kind
    }

    pub(crate) fn new(kind: T, debug_context: Option<String>) -> Self {
        Self {
            kind,
            debug_context,
        }
    }

    pub(crate) fn debug_line<Ctxt>(&self, ctxt: Ctxt) -> String
    where
        T: DisplayWithCtxt<Ctxt>,
    {
        self.kind.to_short_string(ctxt)
    }
}

impl<Ctxt, T: DisplayWithCtxt<Ctxt>> ToJsonWithCtxt<Ctxt> for ActionKindWithDebugCtxt<T> {
    fn to_json(&self, ctxt: Ctxt) -> serde_json::Value {
        let mut map = Map::new();
        map.insert("kind".to_string(), self.kind.to_short_string(ctxt).into());
        if let Some(debug_context) = &self.debug_context {
            map.insert(
                "debug_context".to_string(),
                debug_context.to_string().into(),
            );
        } else {
            map.insert("debug_context".to_string(), serde_json::Value::Null);
        }
        map.into()
    }
}

/// An action applied to the Owned PCG during the PCG analysis
/// for which consumers (e.g. Prusti) may wish to perform
/// their own effect (e.g. folding a predicate).
pub type OwnedPcgAction<'tcx> = ActionKindWithDebugCtxt<RepackOp<'tcx>>;

/// An action applied to the Borrow PCG during the PCG analysis
/// for which consumers (e.g. Prusti) may wish to perform
/// their own effect (e.g. for an unblock, applying a magic wand).
pub type BorrowPcgAction<'tcx, EdgeKind = BorrowPcgEdgeKind<'tcx>> =
    ActionKindWithDebugCtxt<BorrowPcgActionKind<'tcx, EdgeKind>>;

/// An action applied to the PCG during the PCG analysis.
#[allow(clippy::large_enum_variant)]
#[derive(Clone, PartialEq, Eq, Debug, From)]
pub enum PcgAction<'tcx, EdgeKind = BorrowPcgEdgeKind<'tcx>> {
    Borrow(BorrowPcgAction<'tcx, EdgeKind>),
    Owned(OwnedPcgAction<'tcx>),
}

impl<'tcx> PcgAction<'tcx> {
    pub(crate) fn restore_capability<'a>(
        place: Place<'tcx>,
        capability: CapabilityKind,
        debug_context: impl Into<String>,
        ctxt: impl HasCompilerCtxt<'a, 'tcx>,
    ) -> Self
    where
        'tcx: 'a,
    {
        if place.is_owned(ctxt) {
            PcgAction::Owned(OwnedPcgAction {
                kind: RepackOp::RegainLoanedCapability(place, capability),
                debug_context: Some(debug_context.into()),
            })
        } else {
            BorrowPcgAction::restore_capability(place, capability, debug_context).into()
        }
    }

    pub(crate) fn debug_line<'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>>(&self, ctxt: Ctxt) -> String
    where
        'tcx: 'a,
    {
        match self {
            PcgAction::Borrow(action) => action.debug_line(ctxt),
            PcgAction::Owned(action) => action.debug_line(ctxt),
        }
    }
}

impl<'a, 'tcx: 'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>> ToJsonWithCtxt<Ctxt> for PcgAction<'tcx> {
    fn to_json(&self, ctxt: Ctxt) -> serde_json::Value {
        match self {
            PcgAction::Borrow(action) => action.to_json(ctxt),
            PcgAction::Owned(action) => action.to_json(ctxt),
        }
    }
}
