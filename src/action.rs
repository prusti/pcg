//! Actions describing manipulations of the PCG.
use derive_more::{Deref, DerefMut, From};
use serde_derive::Serialize;

use crate::{
    borrow_pcg::{
        action::{BorrowPcgActionKind, BorrowPcgActionKindDebugRepr, actions::BorrowPcgActions},
        edge::kind::BorrowPcgEdgeKind,
        unblock_graph::BorrowPcgUnblockAction,
    },
    owned_pcg::{RegainedCapability, RepackOp},
    pcg::capabilities::CapabilityKind,
    utils::{DebugRepr, HasBorrowCheckerCtxt, HasCompilerCtxt, Place, display::DisplayWithCtxt},
};

/// An ordered list of PCG actions, generated by the PCG analysis (typically as
/// the result of analyzing a statement)
#[derive(Clone, PartialEq, Eq, Debug, From, Default, Deref, DerefMut)]
pub struct PcgActions<'tcx>(pub(crate) Vec<PcgAction<'tcx>>);

impl<'a, 'tcx: 'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>> DebugRepr<Ctxt> for PcgActions<'tcx> {
    type Repr = Vec<PcgActionDebugRepr>;

    fn debug_repr(&self, ctxt: Ctxt) -> Self::Repr {
        self.0.iter().map(|a| a.debug_repr(ctxt)).collect()
    }
}

impl<'tcx> From<BorrowPcgActions<'tcx>> for PcgActions<'tcx> {
    fn from(actions: BorrowPcgActions<'tcx>) -> Self {
        PcgActions(actions.0.into_iter().map(|a| a.into()).collect::<Vec<_>>())
    }
}

impl<'tcx> From<Vec<OwnedPcgAction<'tcx>>> for PcgActions<'tcx> {
    fn from(actions: Vec<OwnedPcgAction<'tcx>>) -> Self {
        PcgActions(actions.into_iter().map(|a| a.into()).collect::<Vec<_>>())
    }
}

impl<'tcx> PcgActions<'tcx> {
    pub(crate) fn extend(&mut self, actions: PcgActions<'tcx>) {
        self.0.extend(actions.0);
    }

    /// The subset of actions applied to the Borrow PCG.
    pub fn borrow_pcg_actions(&self) -> BorrowPcgActions<'tcx> {
        BorrowPcgActions(
            self.0
                .iter()
                .filter_map(|action| match action {
                    PcgAction::Borrow(action) => Some(action.clone()),
                    _ => None,
                })
                .collect(),
        )
    }

    pub fn iter(&self) -> impl Iterator<Item = &PcgAction<'tcx>> {
        self.0.iter()
    }

    /// The subset of actions applied to the Owned PCG.
    pub fn owned_pcg_actions(&self) -> Vec<&OwnedPcgAction<'tcx>> {
        self.0
            .iter()
            .filter_map(|action| match action {
                PcgAction::Owned(action) => Some(action),
                _ => None,
            })
            .collect()
    }

    /// The subset of actions that unblock nodes in the Borrow PCG.
    pub fn borrow_pcg_unblock_actions(&self) -> Vec<BorrowPcgUnblockAction<'tcx>> {
        self.0
            .iter()
            .filter_map(|action| match action {
                PcgAction::Borrow(BorrowPcgAction {
                    kind: BorrowPcgActionKind::RemoveEdge(edge),
                    ..
                }) => Some(BorrowPcgUnblockAction::new(edge.clone())),
                _ => None,
            })
            .collect()
    }
}

/// A pair of a PCG action and a debug context (indicating the source of the
/// action).
#[derive(Clone, Debug, PartialEq, Eq, Serialize)]
#[cfg_attr(feature = "type-export", derive(specta::Type))]
pub struct ActionKindWithDebugCtxt<T> {
    pub(crate) kind: T,
    pub(crate) debug_context: Option<String>,
}

impl<T> ActionKindWithDebugCtxt<T> {
    pub fn kind(&self) -> &T {
        &self.kind
    }

    pub(crate) fn new(kind: T, debug_context: Option<String>) -> Self {
        Self {
            kind,
            debug_context,
        }
    }

    pub(crate) fn debug_line<Ctxt>(&self, ctxt: Ctxt) -> String
    where
        T: DisplayWithCtxt<Ctxt>,
    {
        self.kind.display_string(ctxt)
    }
}

impl<Ctxt, T: DebugRepr<Ctxt>> DebugRepr<Ctxt> for ActionKindWithDebugCtxt<T> {
    type Repr = ActionKindWithDebugCtxt<T::Repr>;

    fn debug_repr(&self, ctxt: Ctxt) -> Self::Repr {
        ActionKindWithDebugCtxt {
            kind: self.kind.debug_repr(ctxt),
            debug_context: self.debug_context.clone(),
        }
    }
}

/// An action applied to the Owned PCG during the PCG analysis
/// for which consumers (e.g. Prusti) may wish to perform
/// their own effect (e.g. folding a predicate).
pub type OwnedPcgAction<'tcx> = ActionKindWithDebugCtxt<RepackOp<'tcx>>;

/// An action applied to the Borrow PCG during the PCG analysis
/// for which consumers (e.g. Prusti) may wish to perform
/// their own effect (e.g. for an unblock, applying a magic wand).
pub type BorrowPcgAction<'tcx, EdgeKind = BorrowPcgEdgeKind<'tcx>> =
    ActionKindWithDebugCtxt<BorrowPcgActionKind<'tcx, EdgeKind>>;

/// An action applied to the PCG during the PCG analysis.
#[allow(clippy::large_enum_variant)]
#[derive(Clone, PartialEq, Eq, Debug, From)]
pub enum PcgAction<'tcx, EdgeKind = BorrowPcgEdgeKind<'tcx>> {
    Borrow(BorrowPcgAction<'tcx, EdgeKind>),
    Owned(OwnedPcgAction<'tcx>),
}

#[derive(Serialize)]
#[cfg_attr(feature = "type-export", derive(specta::Type))]
#[serde(tag = "type", content = "data")]
pub(crate) enum PcgActionDebugRepr {
    Owned(ActionKindWithDebugCtxt<RepackOp<'static, String, String, String>>),
    Borrow(ActionKindWithDebugCtxt<BorrowPcgActionKindDebugRepr>),
}

impl<'a, 'tcx: 'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>> DebugRepr<Ctxt> for PcgAction<'tcx> {
    type Repr = PcgActionDebugRepr;

    fn debug_repr(&self, ctxt: Ctxt) -> Self::Repr {
        match self {
            PcgAction::Borrow(action) => PcgActionDebugRepr::Borrow(action.debug_repr(ctxt)),
            PcgAction::Owned(action) => PcgActionDebugRepr::Owned(action.debug_repr(ctxt)),
        }
    }
}

impl<'tcx> PcgAction<'tcx> {
    pub(crate) fn restore_capability<'a>(
        place: Place<'tcx>,
        capability: CapabilityKind,
        debug_context: impl Into<String>,
        ctxt: impl HasCompilerCtxt<'a, 'tcx>,
    ) -> Self
    where
        'tcx: 'a,
    {
        if place.is_owned(ctxt) {
            PcgAction::Owned(OwnedPcgAction {
                kind: RepackOp::RegainLoanedCapability(RegainedCapability::new(place, capability)),
                debug_context: Some(debug_context.into()),
            })
        } else {
            BorrowPcgAction::restore_capability(place, capability, debug_context).into()
        }
    }

    pub(crate) fn debug_line<'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>>(&self, ctxt: Ctxt) -> String
    where
        'tcx: 'a,
    {
        match self {
            PcgAction::Borrow(action) => action.debug_line(ctxt),
            PcgAction::Owned(action) => action.debug_line(ctxt),
        }
    }
}
