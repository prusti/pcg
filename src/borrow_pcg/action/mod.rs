//! Actions applied to the Borrow PCG, as generated by the PCG analysis.

use std::marker::PhantomData;

use serde_derive::Serialize;

use super::borrow_pcg_edge::BorrowPcgEdge;
use crate::{
    RestoreCapability, Weaken,
    action::BorrowPcgAction,
    borrow_pcg::{
        edge::{
            borrow_flow::private::FutureEdgeKind,
            kind::{BorrowPcgEdgeKind, BorrowPcgEdgeType},
        },
        edge_data::{LabelEdgePlaces, LabelNodePredicate, NodeReplacement},
        has_pcs_elem::PlaceLabeller,
        region_projection::{LifetimeProjection, LifetimeProjectionLabel},
    },
    pcg::{CapabilityKind, PcgNodeType},
    utils::{
        DebugRepr, HasBorrowCheckerCtxt, Place, SnapshotLocation,
        data_structures::HashSet,
        display::{DisplayOutput, DisplayWithCtxt, OutputMode},
        maybe_old::MaybeLabelledPlace,
    },
};

pub mod actions;

/// The result of applying an action to the PCG.
#[derive(Clone, Debug, PartialEq, Eq, Serialize)]
#[cfg_attr(feature = "type-export", derive(specta::Type))]
pub(crate) struct ApplyActionResult<Summary = DisplayOutput> {
    /// Whether the action had any effect on the PCG state.
    pub changed: bool,
    /// A summary of the changes made by the action.
    pub change_summary: Summary,
}

impl DebugRepr<()> for ApplyActionResult {
    type Repr = ApplyActionResult<String>;

    fn debug_repr(&self, _ctxt: ()) -> Self::Repr {
        ApplyActionResult {
            changed: self.changed,
            change_summary: self.change_summary.clone().into_html().to_string(),
        }
    }
}

impl ApplyActionResult {
    pub(crate) fn changed_no_display() -> Self {
        Self {
            changed: true,
            change_summary: DisplayOutput::EMPTY,
        }
    }

    pub(crate) fn from_changed(changed: bool) -> Self {
        Self {
            changed,
            change_summary: DisplayOutput::EMPTY,
        }
    }
}

impl<'tcx, EdgeKind, P> BorrowPcgAction<'tcx, EdgeKind, P> {
    pub(crate) fn add_edge(
        edge: BorrowPcgEdge<'tcx, EdgeKind>,
        context: impl Into<DisplayOutput>,
    ) -> Self {
        BorrowPcgAction {
            kind: BorrowPcgActionKind::AddEdge { edge },
            debug_context: Some(context.into()),
        }
    }

    pub(crate) fn remove_edge(
        edge: BorrowPcgEdge<'tcx, EdgeKind>,
        context: impl Into<DisplayOutput>,
    ) -> Self {
        BorrowPcgAction {
            kind: BorrowPcgActionKind::RemoveEdge(edge),
            debug_context: Some(context.into()),
        }
    }
}

impl<'tcx> BorrowPcgAction<'tcx> {
    pub(crate) fn restore_capability(
        place: Place<'tcx>,
        capability: CapabilityKind,
        debug_context: impl Into<DisplayOutput>,
    ) -> Self {
        BorrowPcgAction {
            kind: BorrowPcgActionKind::Restore(RestoreCapability::new(place, capability)),
            debug_context: Some(debug_context.into()),
        }
    }

    pub(crate) fn weaken<'a>(
        place: Place<'tcx>,
        from: CapabilityKind,
        to: Option<CapabilityKind>,
        context: impl Into<DisplayOutput>,
    ) -> Self
    where
        'tcx: 'a,
    {
        BorrowPcgAction {
            kind: BorrowPcgActionKind::Weaken(Weaken::new(place, from, to)),
            debug_context: Some(context.into()),
        }
    }

    pub(crate) fn remove_lifetime_projection_label(
        projection: LifetimeProjection<'tcx, MaybeLabelledPlace<'tcx>>,
        context: impl Into<DisplayOutput>,
    ) -> Self {
        BorrowPcgAction {
            kind: BorrowPcgActionKind::remove_lifetime_projection_label(projection),
            debug_context: Some(context.into()),
        }
    }

    pub(crate) fn label_lifetime_projection(
        predicate: LabelNodePredicate<'tcx>,
        label: Option<LifetimeProjectionLabel>,
        context: impl Into<DisplayOutput>,
    ) -> Self {
        BorrowPcgAction {
            kind: BorrowPcgActionKind::label_lifetime_projection(predicate, label),
            debug_context: Some(context.into()),
        }
    }

    pub(crate) fn label_place_and_update_related_capabilities(
        place: Place<'tcx>,
        location: SnapshotLocation,
        reason: LabelPlaceReason,
    ) -> Self {
        BorrowPcgAction {
            kind: BorrowPcgActionKind::LabelPlace(LabelPlaceAction::new(place, location, reason)),
            debug_context: None,
        }
    }
}

#[deprecated(note = "Use LabelPlaceReason instead")]
pub type MakePlaceOldReason = LabelPlaceReason;

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum LabelPlaceReason {
    StorageDead,
    MoveOut,
    /// When joining an owned place where one place has capability Read and the
    /// other has capability Write, all borrowed expansions of the place with
    /// Read capability should be labelled.
    ///
    /// In particular, the Read capability place could be a shared reference that is dereferenced.
    /// The place will not have any capability after the join, but reborrows derived from the dereference
    /// may still have capability.
    JoinOwnedReadAndWriteCapabilities,
    Write,
    Collapse,
}

impl LabelPlaceReason {
    pub(crate) fn apply_to_edge<'a, 'tcx: 'a, P: Copy>(
        self,
        place: P,
        edge: &mut impl LabelEdgePlaces<'tcx, P>,
        labeller: &impl PlaceLabeller<'tcx>,
        ctxt: impl HasBorrowCheckerCtxt<'a, 'tcx>,
    ) -> HashSet<NodeReplacement<'tcx>> {
        let predicate: LabelNodePredicate<'tcx, P> = match self {
            LabelPlaceReason::StorageDead
            | LabelPlaceReason::MoveOut
            | LabelPlaceReason::JoinOwnedReadAndWriteCapabilities => {
                LabelNodePredicate::PlaceIsPostfixOf(place)
            }
            LabelPlaceReason::Write => LabelNodePredicate::And(vec![
                LabelNodePredicate::PlaceIsPostfixOf(place),
                // If the place is e.g *x or x.f, don't label it if it
                // is the target of a borrow expansion or deref edge.
                LabelNodePredicate::not(LabelNodePredicate::And(vec![
                    LabelNodePredicate::PlaceEquals(place),
                    LabelNodePredicate::InTargetNodes,
                    LabelNodePredicate::NodeType(PcgNodeType::Place),
                    LabelNodePredicate::Or(vec![
                        LabelNodePredicate::EdgeType(BorrowPcgEdgeType::BorrowPcgExpansion),
                        LabelNodePredicate::EdgeType(BorrowPcgEdgeType::Deref),
                    ]),
                ])),
                // If we are writing to e.g. x.f and there's an
                // edge "x.f|'a -> x|'a  at FUTURE", we DONT want to label the source:
                // the stuff that will reside in x'|a will be determined by the new contents of x.f|'a
                // We don't want an edge like "x.f at bb2[6] |'a -> x|'a at FUTURE"
                LabelNodePredicate::not(LabelNodePredicate::And(vec![
                    LabelNodePredicate::PlaceEquals(place),
                    LabelNodePredicate::InSourceNodes,
                    LabelNodePredicate::EdgeType(BorrowPcgEdgeType::BorrowFlow {
                        future_edge_kind: Some(FutureEdgeKind::FromExpansion),
                    }),
                ])),
            ]),
            LabelPlaceReason::Collapse => LabelNodePredicate::PlaceEquals(place),
        };
        let mut result = edge.label_blocked_by_places(&predicate, labeller, ctxt.bc_ctxt());
        result.extend(edge.label_blocked_places(&predicate, labeller, ctxt.bc_ctxt()));
        result
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct LabelPlaceAction<'tcx, P = Place<'tcx>> {
    pub(crate) place: P,
    pub(crate) location: SnapshotLocation,
    pub(crate) reason: LabelPlaceReason,
    _marker: PhantomData<&'tcx ()>,
}

impl<'tcx, P> LabelPlaceAction<'tcx, P> {
    pub(crate) fn new(place: P, location: SnapshotLocation, reason: LabelPlaceReason) -> Self {
        Self {
            place,
            location,
            reason,
            _marker: PhantomData,
        }
    }
}

impl<'a, 'tcx: 'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>> DisplayWithCtxt<Ctxt>
    for LabelPlaceAction<'tcx>
{
    fn display_output(&self, ctxt: Ctxt, _mode: OutputMode) -> DisplayOutput {
        DisplayOutput::Text(
            format!(
                "Label place {} ({:?})",
                self.place.display_string(ctxt),
                self.reason
            )
            .into(),
        )
    }
}

mod private {
    use crate::{
        borrow_pcg::{
            edge_data::LabelNodePredicate,
            region_projection::{LifetimeProjection, LifetimeProjectionLabel},
        },
        pcg::PcgNode,
        utils::{
            HasBorrowCheckerCtxt,
            display::{DisplayOutput, DisplayWithCtxt, OutputMode},
            maybe_old::MaybeLabelledPlace,
        },
    };

    #[derive(Clone, Debug, PartialEq, Eq)]
    pub struct LabelLifetimeProjectionAction<'tcx> {
        predicate: LabelNodePredicate<'tcx>,
        label: Option<LifetimeProjectionLabel>,
    }

    impl<'tcx> LabelLifetimeProjectionAction<'tcx> {
        pub(crate) fn predicate(&self) -> &LabelNodePredicate<'tcx> {
            &self.predicate
        }

        pub(crate) fn label(&self) -> Option<LifetimeProjectionLabel> {
            self.label
        }

        pub(crate) fn new(
            predicate: LabelNodePredicate<'tcx>,
            label: Option<LifetimeProjectionLabel>,
        ) -> Self {
            Self { predicate, label }
        }

        pub(crate) fn remove_label(
            projection: LifetimeProjection<'tcx, MaybeLabelledPlace<'tcx>>,
        ) -> Self {
            Self {
                predicate: LabelNodePredicate::Equals(PcgNode::LifetimeProjection(
                    projection.rebase(),
                )),
                label: None,
            }
        }
    }

    impl<'a, 'tcx: 'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>> DisplayWithCtxt<Ctxt>
        for LabelLifetimeProjectionAction<'tcx>
    {
        fn display_output(&self, ctxt: Ctxt, mode: OutputMode) -> DisplayOutput {
            let predicate_label = self.predicate.display_output(ctxt, mode);
            if let Some(label) = self.label {
                DisplayOutput::Seq(vec![
                    "Label lifetime projection ".into(),
                    predicate_label,
                    " with label ".into(),
                    label.display_output((), mode),
                ])
            } else {
                DisplayOutput::Seq(vec![
                    "Unlabel lifetime projection ".into(),
                    self.predicate.display_output(ctxt, mode),
                ])
            }
        }
    }
}
use private::LabelLifetimeProjectionAction;

#[derive(Clone, Debug, PartialEq, Eq, strum_macros::EnumDiscriminants)]
#[strum_discriminants(derive(Serialize))]
#[cfg_attr(feature = "type-export", strum_discriminants(derive(specta::Type)))]
pub enum BorrowPcgActionKind<'tcx, EdgeKind = BorrowPcgEdgeKind<'tcx>, P = Place<'tcx>> {
    LabelLifetimeProjection(LabelLifetimeProjectionAction<'tcx>),
    Weaken(Weaken<'tcx, P>),
    Restore(RestoreCapability<'tcx, P>),
    LabelPlace(LabelPlaceAction<'tcx, P>),
    /// Remove an edge from the PCG. In terms of the PCG itself, the validity
    /// conditions associated with the edge are not relevant (there is no
    /// situation where an edge is removed only under certain conditions).
    /// However, clients may be interested in the conditions, for example, the
    /// symbolic-execution based Prusti purification already performs some
    /// filtering on edges based on validity conditions and might want to ignore
    /// removal actions for edges that it already ignored.
    RemoveEdge(BorrowPcgEdge<'tcx, EdgeKind>),
    AddEdge {
        edge: BorrowPcgEdge<'tcx, EdgeKind>,
    },
}

impl<'tcx> BorrowPcgActionKind<'tcx> {
    pub(crate) fn remove_lifetime_projection_label(
        projection: LifetimeProjection<'tcx, MaybeLabelledPlace<'tcx>>,
    ) -> Self {
        Self::LabelLifetimeProjection(LabelLifetimeProjectionAction::remove_label(projection))
    }

    pub(crate) fn label_lifetime_projection(
        predicate: LabelNodePredicate<'tcx>,
        label: Option<LifetimeProjectionLabel>,
    ) -> Self {
        Self::LabelLifetimeProjection(LabelLifetimeProjectionAction::new(predicate, label))
    }
}

#[derive(Serialize)]
#[cfg_attr(feature = "type-export", derive(specta::Type))]
pub(crate) struct BorrowPcgActionKindDebugRepr {
    r#type: BorrowPcgActionKindDiscriminants,
    data: String,
}

impl<'a, 'tcx: 'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>> DebugRepr<Ctxt>
    for BorrowPcgActionKind<'tcx>
{
    type Repr = BorrowPcgActionKindDebugRepr;

    fn debug_repr(&self, ctxt: Ctxt) -> Self::Repr {
        BorrowPcgActionKindDebugRepr {
            r#type: BorrowPcgActionKindDiscriminants::from(self),
            data: self.to_short_string(ctxt),
        }
    }
}

impl<'a, 'tcx: 'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>, EdgeKind: DisplayWithCtxt<Ctxt>>
    DisplayWithCtxt<Ctxt> for BorrowPcgActionKind<'tcx, EdgeKind>
{
    fn display_output(&self, ctxt: Ctxt, mode: OutputMode) -> DisplayOutput {
        match self {
            BorrowPcgActionKind::LabelLifetimeProjection(action) => {
                action.display_output(ctxt, mode)
            }
            BorrowPcgActionKind::Weaken(weaken) => weaken.display_output(ctxt, mode),
            BorrowPcgActionKind::Restore(restore_capability) => {
                restore_capability.display_output(ctxt, mode)
            }
            BorrowPcgActionKind::LabelPlace(action) => action.display_output(ctxt, mode),
            BorrowPcgActionKind::RemoveEdge(edge) => DisplayOutput::join(
                vec!["Remove Edge".into(), edge.display_output(ctxt, mode)],
                DisplayOutput::SPACE,
            ),
            BorrowPcgActionKind::AddEdge { edge } => DisplayOutput::join(
                vec!["Add Edge".into(), edge.display_output(ctxt, mode)],
                DisplayOutput::SPACE,
            ),
        }
    }
}
