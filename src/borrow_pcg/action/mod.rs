//! Actions applied to the Borrow PCG, as generated by the PCG analysis.

use serde_derive::Serialize;

use super::borrow_pcg_edge::BorrowPcgEdge;
use crate::{
    RestoreCapability, Weaken,
    action::BorrowPcgAction,
    borrow_pcg::{
        edge::kind::BorrowPcgEdgeKind,
        edge_data::{LabelEdgePlaces, LabelPlacePredicate},
        has_pcs_elem::{LabelLifetimeProjectionPredicate, PlaceLabeller},
        region_projection::{LifetimeProjection, LifetimeProjectionLabel},
    },
    pcg::CapabilityKind,
    utils::{
        DebugRepr, HasBorrowCheckerCtxt, HasCompilerCtxt, Place, SnapshotLocation,
        display::DisplayWithCtxt, maybe_old::MaybeLabelledPlace,
    },
};

pub mod actions;

impl<'tcx, EdgeKind> BorrowPcgAction<'tcx, EdgeKind> {
    pub(crate) fn add_edge(
        edge: BorrowPcgEdge<'tcx, EdgeKind>,
        context: impl Into<String>,
        _ctxt: impl HasCompilerCtxt<'_, 'tcx>,
    ) -> Self {
        BorrowPcgAction {
            kind: BorrowPcgActionKind::AddEdge { edge },
            debug_context: Some(context.into()),
        }
    }

    pub(crate) fn remove_edge(
        edge: BorrowPcgEdge<'tcx, EdgeKind>,
        context: impl Into<String>,
    ) -> Self {
        BorrowPcgAction {
            kind: BorrowPcgActionKind::RemoveEdge(edge),
            debug_context: Some(context.into()),
        }
    }
}

impl<'tcx> BorrowPcgAction<'tcx> {
    pub(crate) fn restore_capability(
        place: Place<'tcx>,
        capability: CapabilityKind,
        debug_context: impl Into<String>,
    ) -> Self {
        BorrowPcgAction {
            kind: BorrowPcgActionKind::Restore(RestoreCapability::new(place, capability)),
            debug_context: Some(debug_context.into()),
        }
    }

    pub(crate) fn weaken<'a>(
        place: Place<'tcx>,
        from: CapabilityKind,
        to: Option<CapabilityKind>,
        context: impl Into<String>,
    ) -> Self
    where
        'tcx: 'a,
    {
        BorrowPcgAction {
            kind: BorrowPcgActionKind::Weaken(Weaken::new(place, from, to)),
            debug_context: Some(context.into()),
        }
    }

    pub(crate) fn remove_lifetime_projection_label(
        projection: LifetimeProjection<'tcx, MaybeLabelledPlace<'tcx>>,
        context: impl Into<String>,
    ) -> Self {
        BorrowPcgAction {
            kind: BorrowPcgActionKind::LabelLifetimeProjection(
                LabelLifetimeProjectionPredicate::Equals(projection),
                None,
            ),
            debug_context: Some(context.into()),
        }
    }

    pub(crate) fn label_lifetime_projection(
        predicate: LabelLifetimeProjectionPredicate<'tcx>,
        label: Option<LifetimeProjectionLabel>,
        context: impl Into<String>,
    ) -> Self {
        BorrowPcgAction {
            kind: BorrowPcgActionKind::LabelLifetimeProjection(predicate, label),
            debug_context: Some(context.into()),
        }
    }

    pub(crate) fn label_place_and_update_related_capabilities(
        place: Place<'tcx>,
        location: SnapshotLocation,
        reason: LabelPlaceReason,
    ) -> Self {
        BorrowPcgAction {
            kind: BorrowPcgActionKind::MakePlaceOld(LabelPlaceAction {
                place,
                location,
                reason,
            }),
            debug_context: None,
        }
    }
}

#[deprecated(note = "Use LabelPlaceReason instead")]
pub type MakePlaceOldReason = LabelPlaceReason;

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum LabelPlaceReason {
    StorageDead,
    MoveOut,
    /// When joining an owned place where one place has capability Read and the
    /// other has capability Write, all borrowed expansions of the place with
    /// Read capability should be labelled.
    ///
    /// In particular, the Read capability place could be a shared reference that is dereferenced.
    /// The place will not have any capability after the join, but reborrows derived from the dereference
    /// may still have capability.
    JoinOwnedReadAndWriteCapabilities,
    ReAssign,
    LabelDerefProjections {
        shared_refs_only: bool,
    },
    Collapse,
}

impl LabelPlaceReason {
    pub(crate) fn apply_to_edge<'a, 'tcx: 'a>(
        self,
        place: Place<'tcx>,
        edge: &mut impl LabelEdgePlaces<'tcx>,
        labeller: &impl PlaceLabeller<'tcx>,
        ctxt: impl HasBorrowCheckerCtxt<'a, 'tcx>,
    ) -> bool {
        let predicate = match self {
            LabelPlaceReason::StorageDead
            | LabelPlaceReason::MoveOut
            | LabelPlaceReason::JoinOwnedReadAndWriteCapabilities => LabelPlacePredicate::Postfix {
                place,
                label_place_in_expansion: true,
            },
            LabelPlaceReason::ReAssign => LabelPlacePredicate::Postfix {
                place,
                label_place_in_expansion: false,
            },
            LabelPlaceReason::Collapse => LabelPlacePredicate::Exact(place),
            LabelPlaceReason::LabelDerefProjections { shared_refs_only } => {
                LabelPlacePredicate::DerefPostfixOf {
                    place,
                    shared_refs_only,
                }
            }
        };
        let mut changed = edge.label_blocked_by_places(&predicate, labeller, ctxt.bc_ctxt());
        changed |= edge.label_blocked_places(&predicate, labeller, ctxt.bc_ctxt());
        changed
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct LabelPlaceAction<'tcx> {
    pub(crate) place: Place<'tcx>,
    pub(crate) location: SnapshotLocation,
    pub(crate) reason: LabelPlaceReason,
}

impl<'a, 'tcx: 'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>> DisplayWithCtxt<Ctxt>
    for LabelPlaceAction<'tcx>
{
    fn display_string(&self, ctxt: Ctxt) -> String {
        format!(
            "Make {} an old place ({:?})",
            self.place.display_string(ctxt),
            self.reason
        )
    }
}

#[derive(Clone, Debug, PartialEq, Eq, strum_macros::EnumDiscriminants)]
#[strum_discriminants(derive(Serialize))]
#[cfg_attr(feature = "type-export", strum_discriminants(derive(specta::Type)))]
pub enum BorrowPcgActionKind<'tcx, EdgeKind = BorrowPcgEdgeKind<'tcx>> {
    LabelLifetimeProjection(
        LabelLifetimeProjectionPredicate<'tcx>,
        Option<LifetimeProjectionLabel>,
    ),
    Weaken(Weaken<'tcx>),
    Restore(RestoreCapability<'tcx>),
    MakePlaceOld(LabelPlaceAction<'tcx>),
    /// Remove an edge from the PCG. In terms of the PCG itself, the validity
    /// conditions associated with the edge are not relevant (there is no
    /// situation where an edge is removed only under certain conditions).
    /// However, clients may be interested in the conditions, for example, the
    /// symbolic-execution based Prusti purification already performs some
    /// filtering on edges based on validity conditions and might want to ignore
    /// removal actions for edges that it already ignored.
    RemoveEdge(BorrowPcgEdge<'tcx, EdgeKind>),
    AddEdge {
        edge: BorrowPcgEdge<'tcx, EdgeKind>,
    },
}

#[derive(Serialize)]
#[cfg_attr(feature = "type-export", derive(specta::Type))]
pub(crate) struct BorrowPcgActionKindDebugRepr {
    r#type: BorrowPcgActionKindDiscriminants,
    data: String,
}

impl<'a, 'tcx: 'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>> DebugRepr<Ctxt>
    for BorrowPcgActionKind<'tcx>
{
    type Repr = BorrowPcgActionKindDebugRepr;

    fn debug_repr(&self, ctxt: Ctxt) -> Self::Repr {
        BorrowPcgActionKindDebugRepr {
            r#type: BorrowPcgActionKindDiscriminants::from(self),
            data: self.display_string(ctxt),
        }
    }
}

impl<'a, 'tcx: 'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>, EdgeKind: DisplayWithCtxt<Ctxt>>
    DisplayWithCtxt<Ctxt> for BorrowPcgActionKind<'tcx, EdgeKind>
{
    fn display_string(&self, ctxt: Ctxt) -> String {
        match self {
            BorrowPcgActionKind::LabelLifetimeProjection(rp, label) => {
                format!(
                    "Label Region Projection: {} with {:?}",
                    rp.display_string(ctxt),
                    label
                )
            }
            BorrowPcgActionKind::Weaken(weaken) => weaken.debug_line(ctxt.ctxt()),
            BorrowPcgActionKind::Restore(restore_capability) => {
                restore_capability.debug_line(ctxt.ctxt())
            }
            BorrowPcgActionKind::MakePlaceOld(action) => action.display_string(ctxt),
            BorrowPcgActionKind::RemoveEdge(borrow_pcgedge) => {
                format!("Remove Edge {}", borrow_pcgedge.display_string(ctxt))
            }
            BorrowPcgActionKind::AddEdge { edge } => {
                format!("Add Edge: {}", edge.display_string(ctxt),)
            }
        }
    }
}
