use derive_more::{Deref, DerefMut};

use crate::{
    Weaken,
    borrow_pcg::{action::BorrowPcgAction, unblock_graph::BorrowPcgUnblockAction},
    pcg_validity_assert,
    rustc_interface::data_structures::fx::FxHashSet,
    utils::{CompilerCtxt, HasBorrowCheckerCtxt, json::ToJsonWithCtxt},
};

use super::BorrowPcgActionKind;

/// An ordered list of Borrow PCG actions, generated by the PCG analysis
/// (typically as the result of analyzing a statement)
#[derive(Clone, Deref, DerefMut, Debug, Default)]
pub struct BorrowPcgActions<'tcx>(pub(crate) Vec<BorrowPcgAction<'tcx>>);

impl<'a, 'tcx: 'a, Ctxt: HasBorrowCheckerCtxt<'a, 'tcx>> ToJsonWithCtxt<Ctxt>
    for BorrowPcgActions<'tcx>
{
    fn to_json(&self, ctxt: Ctxt) -> serde_json::Value {
        self.0
            .iter()
            .map(|a| a.to_json(ctxt))
            .collect::<Vec<_>>()
            .into()
    }
}

impl<'tcx> BorrowPcgActions<'tcx> {
    /// Actions applied to the PCG, in the order they occurred.
    pub fn actions(&self) -> &[BorrowPcgAction<'tcx>] {
        &self.0
    }

    pub fn weakens(&self) -> FxHashSet<Weaken<'tcx>> {
        self.0
            .iter()
            .filter_map(|action| match action.kind() {
                BorrowPcgActionKind::Weaken(weaken) => Some(*weaken),
                _ => None,
            })
            .collect()
    }

    pub fn unblock_actions(&self) -> Vec<BorrowPcgUnblockAction<'tcx>> {
        self.0
            .iter()
            .filter_map(|action| match action.kind() {
                BorrowPcgActionKind::RemoveEdge(edge) => {
                    Some(BorrowPcgUnblockAction::new(edge.clone()))
                }
                _ => None,
            })
            .collect()
    }
}

impl<'tcx> BorrowPcgActions<'tcx> {
    pub(crate) fn new() -> Self {
        Self(vec![])
    }

    pub(crate) fn last(&self) -> Option<&BorrowPcgAction<'tcx>> {
        self.0.last()
    }

    pub(crate) fn push(&mut self, action: BorrowPcgAction<'tcx>, ctxt: CompilerCtxt<'_, 'tcx>) {
        pcg_validity_assert!(
            self.last() != Some(&action),
            [ctxt],
            "Action {:?} to be pushed is the same as the last pushed action, this is probably a bug.",
            action
        );
        self.0.push(action);
    }
}
