import type { StringOf } from "../generated_type_deps.ts";
// This file has been generated by Specta. DO NOT EDIT.

/**
 * A pair of a PCG action and a debug context (indicating the source of the
 * action and possibly its effects).
 */
export type ActionKindWithDebugCtxt<T, Ctxt> = { kind: T; debug_context: Ctxt };

export type AppliedAction<Action, Result> = { action: Action; result: Result; _marker: null };

/**
 * The result of applying an action to the PCG.
 */
export type ApplyActionResult<Summary> = { 
/**
 * Whether the action had any effect on the PCG state.
 */
changed: boolean; 
/**
 * A summary of the changes made by the action.
 */
change_summary: Summary };

export type BasicBlock = StringOf<BasicBlockMarker>;

export type BasicBlockMarker = { _basic_block: null };

export type BorrowPcgActionKindDebugRepr = { type: BorrowPcgActionKindDiscriminants; data: string };

/**
 * Auto-generated discriminant enum variants
 */
export type BorrowPcgActionKindDiscriminants = "LabelLifetimeProjection" | "Weaken" | "Restore" | "LabelPlace" | 
/**
 * Remove an edge from the PCG. In terms of the PCG itself, the validity
 * conditions associated with the edge are not relevant (there is no
 * situation where an edge is removed only under certain conditions).
 * However, clients may be interested in the conditions, for example, the
 * symbolic-execution based Prusti purification already performs some
 * filtering on edges based on validity conditions and might want to ignore
 * removal actions for edges that it already ignored.
 */
"RemoveEdge" | "AddEdge";

export type BranchChoicesDebugRepr = { from: string; chosen: string[] };

export type CapabilityKind = 
/**
 * For borrowed places only: permits reads from the location, but not writes or
 * drops.
 */
"Read" | 
/**
 * For owned places, this capability is used when the place is moved out
 * of. This capability is used for both owned and borrowed places just before
 * they are overwritten.
 */
"Write" | 
/**
 * Writes and reads are permitted to this place, and the place is not
 * borrowed.
 */
"Exclusive" | 
/**
 * [`CapabilityKind::Exclusive`] for everything not through a dereference,
 * [`CapabilityKind::Write`] for everything through a dereference.
 */
"ShallowExclusive";

export type Conditioned<T, Conditions> = { conditions: Conditions; value: T };

export type DataflowStmtPhase = "Initial" | { EvalStmt: EvalStmtPhase } | { Join: BasicBlock };

export type DisplayOutput = { Html: Html } | { Text: string } | { Both: [Html, string] } | { Seq: DisplayOutput[] };

export type DotFileAtPhase<PhaseKey> = { phase: PhaseKey; filename: PathToDotFile };

export type EvalStmtData<T> = { pre_operands: T; post_operands: T; pre_main: T; post_main: T };

export type EvalStmtPhase = "pre_operands" | "post_operands" | "pre_main" | "post_main";

export type FunctionMetadata = { name: string; source: string; start: SourcePos };

export type GenericPcgAction<Borrow, Owned> = { type: "Borrow"; data: Borrow } | { type: "Owned"; data: Owned };

export type Html = { Text: string } | { Subscript: string } | { Seq: Html[] } | { Font: [string, Html] };

export type MirEdge = { source: string; target: string; label: string };

export type MirGraph = { nodes: MirNode[]; edges: MirEdge[] };

export type MirNode = { id: string; block: number; stmts: MirStmt[]; terminator: MirStmt };

export type MirStmt = { stmt: string; debug_stmt: string; span: MirStmtSpan; loans_invalidated_start: string[]; loans_invalidated_mid: string[]; borrows_in_scope_start: string[]; borrows_in_scope_mid: string[] };

export type MirStmtSpan = { low: SourcePos; high: SourcePos };

export type PathToDotFile = string;

export type PcgBlockVisualizationData = { statements: PcgStmtVisualizationData[]; successors: { [key in BasicBlock]: PcgSuccessorVisualizationData } };

export type PcgStmtVisualizationData = { actions: EvalStmtData<(AppliedAction<GenericPcgAction<ActionKindWithDebugCtxt<BorrowPcgActionKindDebugRepr, string | null>, ActionKindWithDebugCtxt<RepackOp<string, string, string>, string | null>>, ApplyActionResult<string>>)[]>; graphs: StmtGraphs<StringOf<DataflowStmtPhase>> };

export type PcgSuccessorVisualizationData = { actions: (GenericPcgAction<ActionKindWithDebugCtxt<BorrowPcgActionKindDebugRepr, string | null>, ActionKindWithDebugCtxt<RepackOp<string, string, string>, string | null>>)[] };

export type PcgVisualizationData = { [key in BasicBlock]: PcgBlockVisualizationData };

export type RegainedCapability<Place> = { place: Place; capability: CapabilityKind };

export type RepackCollapse<Place, Guide> = { to: Place; capability: CapabilityKind; guide: Guide | null };

export type RepackExpand<Place, Guide> = { from: Place; guide: Guide | null; capability: CapabilityKind };

export type RepackOp<Local, Place, Guide> = 
/**
 * Rust will sometimes join two BasicBlocks where a local is live in one and dead in the other.
 * Our analysis will join these two into a state where the local is dead, and this Op marks the
 * edge from where it was live.
 * 
 * This is not an issue in the MIR since it generally has a
 * [`mir::StatementKind::StorageDead`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.StatementKind.html#variant.StorageDead)
 * right after the merge point, which is fine in Rust semantics, since
 * [`mir::StatementKind::StorageDead`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.StatementKind.html#variant.StorageDead)
 * is a no-op if the local is already (conditionally) dead.
 * 
 * This Op only appears for edges between basic blocks. It is often emitted for edges to panic
 * handling blocks, but can also appear in regular code for example in the MIR of
 * [this function](https://github.com/dtolnay/syn/blob/3da56a712abf7933b91954dbfb5708b452f88504/src/attr.rs#L623-L628).
 */
{ type: "StorageDead"; data: Local } | 
/**
 * This Op only appears within a BasicBlock and is attached to a
 * [`mir::StatementKind::StorageDead`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.StatementKind.html#variant.StorageDead)
 * statement. We emit it for any such statement where the local may already be dead. We
 * guarantee to have inserted a [`RepackOp::StorageDead`] before this Op so that one can
 * safely ignore the statement this is attached to.
 */
{ type: "IgnoreStorageDead"; data: Local } | 
/**
 * Instructs that the current capability to the place (first [`CapabilityKind`]) should
 * be weakened to the second given capability. We guarantee that `_.1 > _.2`.
 * 
 * This Op is used prior to a [`RepackOp::Collapse`] to ensure that all packed up places have
 * the same capability. It can also appear at basic block join points, where one branch has
 * a weaker capability than the other.
 */
{ type: "Weaken"; data: Weaken<Place, CapabilityKind> } | 
/**
 * Instructs that one should unpack `place` with the capability.
 * We guarantee that the current state holds exactly the given capability for the given place.
 * `guide` denotes e.g. the enum variant to unpack to. One can use
 * [`Place::expand_one_level(_.0, _.1, ..)`](Place::expand_one_level) to get the set of all
 * places (except as noted in the documentation for that fn) which will be obtained by unpacking.
 */
{ type: "Expand"; data: RepackExpand<Place, Guide> } | 
/**
 * Instructs that one should pack up `place` with the given capability.
 * `guide` denotes e.g. the enum variant to pack from. One can use
 * [`Place::expand_one_level(_.0, _.1, ..)`](Place::expand_one_level) to get the set of all
 * places which should be packed up. We guarantee that the current state holds exactly the
 * given capability for all places in this set.
 */
{ type: "Collapse"; data: RepackCollapse<Place, Guide> } | 
/**
 * TODO
 */
{ type: "DerefShallowInit"; data: [Place, Place] } | 
/**
 * This place should have its capability changed from `Lent` (for mutably
 * borrowed places) or `Read` (for shared borrow places), to the given
 * capability, because it is no longer lent out.
 */
{ type: "RegainLoanedCapability"; data: RegainedCapability<Place> };

export type SourcePos = { line: number; column: number };

export type StmtGraphs<PhaseKey> = { at_phase: DotFileAtPhase<PhaseKey>[]; actions: EvalStmtData<PathToDotFile[]> };


export type ValidityConditionsDebugRepr = { branch_choices: BranchChoicesDebugRepr[] };

/**
 * Instructs that the current capability to the place (first [`CapabilityKind`]) should
 * be weakened to the second given capability. We guarantee that `_.1 > _.2`.
 * If `_.2` is `None`, the capability is removed.
 */
export type Weaken<Place, ToCap> = { place: Place; from: CapabilityKind; to: ToCap };